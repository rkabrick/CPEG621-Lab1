%{
/* Ryan Kabrick          */
/* CPEG621: Compilers    */
/* Project 1: Infix Calc */
#include <stdio.h>
#include <math.h>
#include <string.h>

#define MAX_FIX 500 /* max size(buf/stack) */
#define MAX_VARS 100 /* max # vars */
#define MAX_VAR_NAME_LENGTH 20 /* Don't be ridiculous w/ the damn variable names */

#define POST 1
#define PREFIX 0
#define UNARY 2 
#define EQUALS 3
#define OPERAND 1
#define OPERATOR 0

/* Generated by flex */
int yylex(void); 

void yyerror(char *);
int VarAssignment(char *, int);
int GetVarVal(char *);
int NewVar(char *);
void VarErrnoHandler(int);

/* post/pre-fix ~shit~ */
void PushInt(int, int);
void PushStr(int, char*);
int Pop(char*);
/***/

int GetType(char*);
void StrncatCheck(char*, char*);
void ReversePostfix();

struct variable {
  char Name[MAX_VAR_NAME_LENGTH + 1];
  int Val;
};

struct variable VarList[MAX_VARS];
unsigned LineNum = 1;
int NumVars = 0;

/* NEW */
char PrefixStack[MAX_FIX][MAX_FIX];
char PostfixBuf[MAX_FIX][MAX_FIX];
unsigned PostSize = 0, PrefixSP = 0;

%}

%token INT VAR POW

%union { int Value; char *VarName; }

/* Declare Value type of each union symbol */
%type <Value> expr INT
%type <VarName> VAR

/* Operator precedence as dictated in the cppreference */
%token <d> NUMBER
%token '(' ')'
%left '+' '-'
%left '*' '/'
%right '!'
%right POW

%start prefix

%% 

prefix : prefix stmt '\n' | ;

stmt : expr { ReversePostfix(); printf("=%d\n", $1); }
		| VAR '=' expr {
			PushStr(POST, $1);
			PushStr(POST, "= ");
			ReversePostfix();
			printf("=%d\n", VarAssignment($1, $3));
			free($1);
		};

expr :
	INT { $$ = $1; PushInt(POST, $1); }	  
	| VAR        { $$ = GetVarVal($1); PushStr(POST, $1); free($1); }
	| expr '*' expr   { $$ = $1 * $3; PushStr(POST, "*"); }
	| expr '/' expr   { $$ = $1 / $3; PushStr(POST, "/"); }
	| expr '+' expr   { $$ = $1 + $3; PushStr(POST, "+"); }
	| expr '-' expr   { $$ = $1 - $3; PushStr(POST, "-"); }
	| '!' expr		  { $$ = ~$2; PushStr(POST, "!"); } 
	| expr POW expr { $$ = (int)pow($1, $3); PushStr(POST, "**"); }
	| '(' expr ')'    { $$ = $2; }		
	;

%%
/* assign var values */
int VarAssignment(char* VarName, int Val) {
	/* if it exists already, reassign */
	int i = 0;
	for(i = 0; i < NumVars; i++) {
		if (strcmp(VarList[i].Name, VarName) == 0) {
			VarList[i].Val = Val;
			return VarList[i].Val;
		}
	}
	/* can it be added */
	i = NewVar(VarName);
	if (i >= 0) {
		VarList[i].Val = Val;
		return VarList[i].Val;
	}
	/* something went wrong if you get here */
	VarErrnoHandler(i);
	return 0;
}

/* return current val of variable */
int GetVarVal(char *VarName) {
	int i = 0;
	for(i = 0; i < NumVars; i++) {
		if (strcmp(VarList[i].Name, VarName) == 0) {
			return VarList[i].Val;
		}
	}

	i = NewVar(VarName);
	if (i >= 0)	{
		return VarList[i].Val;	
	}
	/* somthing went wrong */
	return 0;	
}

int NewVar(char *VarName) {
	if (NumVars >= MAX_VARS) {
		return -1;
	}
	int Len = strlen(VarName);

	if(Len > MAX_VAR_NAME_LENGTH)	{
		return -2;
	}

	strncpy(VarList[NumVars].Name, VarName, Len);
	VarList[NumVars].Val = 0;	
	NumVars++;

	return NumVars - 1;
}

void VarErrnoHandler(int error) {
	switch(error)	{
		case -1:
			yyerror("Max number of variables already declared");
			break;
		case -2:
			yyerror("Variable name exceeds max length");
			break;
		default:
			yyerror("Unknown error code");
	}
}

void PushInt(int BufID, int i){
	if( BufID != POST){  
		if( PrefixSP > MAX_FIX - 1 ){
			yyerror("prefix stack error");
			return;
		}
		sprintf(PrefixStack[PrefixSP], "%d", i);
		PrefixSP++;
		return;
	}
	else {
		if(PostSize > MAX_FIX - 1){
			yyerror("postfix buf overloaded");
			return;
		}
		sprintf(PostfixBuf[PostSize], "%d", i);
		PostSize++;
		return;
	}
}
	
void PushStr(int BufID, char* Str){
	/* Prefix */
	if( BufID != POST){  
		if( PrefixSP > MAX_FIX - 1 ){
			yyerror("prefix stack overflow");
			return;
		}
		strncpy(PrefixStack[PrefixSP], Str, MAX_FIX);
		PrefixSP++;
		return;
	}
	else {
		if(PostSize > MAX_FIX-1){
			yyerror("post buf overflow");
			return;
		}
		strncpy(PostfixBuf[PostSize], Str, MAX_FIX);
		PostSize++;
		return;
	}
}

int Pop(char *First){
	if(PrefixSP <= 0)
		return 0;

	strncpy(First, PrefixStack[PrefixSP - 1], MAX_FIX);
	PrefixSP--;
	return 1;
}

// Identify whether string is an operator, unary operator, or operand
int GetType(char *c) {
	if(strcmp(c, "+") == 0
		|| strcmp(c, "-") == 0
		|| strcmp(c, "*") == 0
		|| strcmp(c, "/") == 0
		|| strcmp(c, "**") == 0)
		return OPERATOR;

	else if(strcmp(c, "!") == 0)
		return UNARY;
	else if(strcmp(c, "=") == 0)
		return EQUALS;
	else
		return OPERAND;	
}

void StrncatCheck(char *Dest, char *Src) {
	int RemainingSpace = MAX_FIX - strlen(Dest) - 1;
	int StrToCopy = RemainingSpace; 

	if (strlen(Src) > RemainingSpace)
		yyerror("stack elem too big");

	strncat(Dest, Src, StrToCopy);
	return;
} 

/* prints out reverse of the accumulated prefix */
void ReversePostfix() {
	int i, type;
 	char PreTmp1[MAX_FIX];
	char PreTmp2[MAX_FIX];
	char PreTmp3[MAX_FIX];

	for(i = 0; i < PostSize; i++)
	{
		/* get type */
		type = GetType(PostfixBuf[i]);

		if(type == OPERATOR){
			/* get top two stack elems */
			Pop(PreTmp1);
			Pop(PreTmp2);

			/* op + val2 + val1  */
			sprintf(PreTmp3, "%s", PostfixBuf[i]);	
			StrncatCheck(PreTmp3, PreTmp2);	
			StrncatCheck(PreTmp3, PreTmp1);

			/* put on stack */
			PushStr(PREFIX, PreTmp3);
		}
		else if (type == UNARY) {
			Pop(PreTmp1);
			sprintf(PreTmp2, "%c", PreTmp1[0]);
			if (GetType(PreTmp2) == OPERAND)
				/* unary space */
				sprintf(PreTmp3, "%s ", PostfixBuf[i]); 
			else
				/* unary no space */
				sprintf(PreTmp3, "%s ", PostfixBuf[i]); 
			StrncatCheck(PreTmp3, PreTmp1);
			PushStr(PREFIX, PreTmp3);
		}
		else if(type == EQUALS)	{
			Pop(PreTmp1);
			Pop(PreTmp2);
			sprintf(PreTmp3, "%s ", PostfixBuf[i]); /* op + val1 + val2 */
			StrncatCheck(PreTmp3, PreTmp1);
			StrncatCheck(PreTmp3, PreTmp2);
			/* str to stack */
			PushStr(PREFIX, PreTmp3);
		}
		/* if operand */
		else {
			sprintf(PreTmp1, "%s ", PostfixBuf[i]);
			PushStr(PREFIX, PreTmp1);
		}
	}
	/* last elem should be everything we need */
	Pop(PreTmp1); 		
	printf("%s\n", PreTmp1);

	/* reset for next op */
	PrefixSP = 0;
	PostSize = 0;
	return;
}

void yyerror(char *s){
	printf("%s\n", s);
}

int main(){
	memset(VarList, 0, sizeof(int) * MAX_VARS);
	yyparse();
	return 0;
}

